""" Small utilities (e.g., path helpers, display functions). """
import argparse
from typing import Any, Dict


class CustomFormatter(argparse.RawTextHelpFormatter):
    # (This class is good, no changes needed)
    def _format_action_invocation(self, action):
        if not action.option_strings: return super()._format_action_invocation(action)
        parts = list(action.option_strings)
        if action.nargs != 0:
            metavar = self._format_args(action, action.dest.upper())
            parts[-1] += f" {metavar}"
        return ', '.join(parts)


def display_file_tree(
    tree: dict | None,
    indent: str = "",
    is_last: bool = True,
    is_root: bool = True
):
    # (This function is good, no changes needed)
    if tree is None: return
    icon = "" if tree["type"] == "directory" else ""
    if is_root:
        print(f"{icon}{tree['name']}")
    else:
        branch = "╰── " if is_last else "├── "
        print(f"{indent}{branch}{icon}{tree['name']}")
    if tree["type"] == "directory":
        children = tree.get("children", [])
        for i, child in enumerate(children):
            last = (i == len(children) - 1)
            new_indent = indent + ("    " if is_last else "│   ")
            display_file_tree(child, indent=new_indent, is_last=last, is_root=False)


def _format_size(size_bytes: float) -> str:
    # (This function is good, no changes needed)
    if size_bytes is None: return ""
    # Corrected to handle int conversion for B
    if size_bytes < 1024: return f"{int(size_bytes)} B"
    for unit in ["KB", "MB", "GB", "TB"]:
        size_bytes /= 1024.0
        if size_bytes < 1024.0: return f"{size_bytes:.1f} {unit}"
    return f"{size_bytes:.1f} PB"


def display_project_context(context_tree: Dict[str, Any]):
    """
    Prints a formatted, text-only, human-readable representation of the
    project context tree generated by `crawl_project_context`.

    Args:
        context_tree: The nested dictionary from the context crawler.
    """
    if not context_tree:
        print("Project context is empty or could not be generated.")
        return
    # Print the root name without any branch connectors.
    print(f"{context_tree['name']}/")
    # Recursively display only the children of the root.
    children = context_tree.get("children", [])
    for i, child in enumerate(children):
        is_child_last = (i == len(children) - 1)
        # Start recursion with an empty prefix.
        _display_node(child, prefix="", is_last=is_child_last)


def _display_node(node: Dict[str, Any], prefix: str, is_last: bool):
    """Recursively displays a node (file or directory) in the context tree."""
    # --- Connector and Name ---
    connector = "╰── " if is_last else "├── "
    name = node.get("name", "Unknown")

    if node.get("type") == "directory":
        print(f"{prefix}{connector}{name}/")
    else:  # It's a file
        size_str = f"({_format_size(node.get('size', 0))})"
        lang_str = f"[{node.get('language', 'unknown')}]"
        print(f"{prefix}{connector}{name} {lang_str} {size_str}")

    # --- FIX: This prefix is for children AND for the details of the current node ---
    detail_prefix = prefix + ("    " if is_last else "│   ")

    # --- Summary and Metadata for Files (Additive Display) ---
    if node.get("type") == "file":
        summary = node.get("summary")
        metadata = {k: v for k, v in node.get("metadata", {}).items() if v}

        # No longer need to delete description, as we want to show both.
        if summary:
            print(f"{detail_prefix}  ↪ summary: {summary}")

        for key, value in metadata.items():
            print(f"{detail_prefix}  ↪ {key}: {value}")

    # --- Recursive Call for Children of a Directory ---
    if node.get("type") == "directory":
        children = node.get("children", [])
        for i, child in enumerate(children):
            is_child_last = (i == len(children) - 1)
            # The prefix for the next level is the detail_prefix we just calculated
            _display_node(child, prefix=detail_prefix, is_last=is_child_last)
